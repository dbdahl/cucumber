% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slice_samplerd.R, R/slice_samplers.R
\name{slice_sampler_generalized_elliptical}
\alias{slice_sampler_generalized_elliptical}
\title{General Elliptical Slice Sampler (Univariate)}
\usage{
slice_sampler_generalized_elliptical(
  x,
  target,
  mu = 2,
  sigma = 5,
  df,
  log = TRUE
)

slice_sampler_generalized_elliptical(
  x,
  target,
  mu = 2,
  sigma = 5,
  df,
  log = TRUE
)
}
\arguments{
\item{x}{The current state (as a numeric scalar).}

\item{target}{A function taking numeric scalar that evaluates the target (or,
if \code{log = TRUE}, the log of the target) density, returning a numeric scalar.}

\item{mu}{A numeric scalar tuning the algorithm which gives the theta value that will be used to sample a random value from the ellipse.}

\item{sigma}{A numeric scalar tuning the algorithm which gives the theta value that will be used to sample a random value from the ellipse.}

\item{df}{Degrees of freedom of Student t pseudo-target.}

\item{log}{If \code{FALSE}, the \code{target} function is the density
function of the target distribution.  If \code{TRUE}, the \code{target}
function evaluates the log of the density of the target distribution.}
}
\value{
A list contains two elements: "x" is the new state and "nEvaluations"
is the number of evaluations of the target function used to obtain the new
state.

A list contains two elements: "x" is the new state and "nEvaluations"
is the number of evaluations of the target function used to obtain the new
state.
}
\description{
General Elliptical Slice Sampler of Nishihara (2014)

General Elliptical Slice Sampler of Nishihara (2014)
}
\examples{
lf <- function(x) dbeta(x, 3, 4, log = TRUE)
draws <- numeric(1000)
nEvaluations <- 0L
seconds <- system.time({
  for (i in seq.int(2, length(draws))) {
    out <- slice_sampler_generalized_elliptical(draws[i - 1], target = lf,
                                                mu = 0.5, sigma = 1, df = 5)
    draws[i] <- out$x
    nEvaluations <- nEvaluations + out$nEvaluations
  }
})["elapsed"]
nEvaluations / length(draws)
nEvaluations / ess(draws)
ess(draws) / seconds
plot(density(draws), xlim = c(0, 1))
curve(exp(lf(x)), 0, 1, col = "blue", add = TRUE)

lf <- function(x) dbeta(x, 3, 4, log = TRUE)
draws <- numeric(1000)
nEvaluations <- 0L
seconds <- system.time({
  for (i in seq.int(2, length(draws))) {
    out <- slice_sampler_generalized_elliptical(draws[i - 1], target = lf,
                                                mu = 0.5, sigma = 1, df = 5)
    draws[i] <- out$x
    nEvaluations <- nEvaluations + out$nEvaluations
  }
})["elapsed"]
nEvaluations / length(draws)
nEvaluations / ess(draws)
ess(draws) / seconds
plot(density(draws), xlim = c(0, 1))
curve(exp(lf(x)), 0, 1, col = "blue", add = TRUE)

}
