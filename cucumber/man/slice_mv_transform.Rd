% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hyperrectangle_slice.R
\name{slice_mv_transform}
\alias{slice_mv_transform}
\title{Multivariate Transform Slice Sampler}
\usage{
slice_mv_transform(x, target, pseudo_log_pdf, pseudo_inv_cdf, pseudo_cdf)
}
\arguments{
\item{x}{The current state (as a numeric vector).}

\item{target}{A function taking numeric vector that evaluates the log-target
density, returning a numeric scalar.}

\item{pseudo_log_pdf}{List of functions evaluating each of the univariate log pdfs of the pseudo-target.}

\item{pseudo_inv_cdf}{List of functions evaluating each of the univariate inverse-cdfs of the pseudo-target.}

\item{pseudo_cdf}{List of functions evaluating each of the univariate cdfs of the pseudo-target.}
}
\value{
A list containing three elements: "x" is the new state, "u" is the
value of the CDF of the psuedo-target associated with the returned value,
inverse CDF method, and "nEvaluations is the number of evaluations of the
target function used to obtain the new state.
}
\description{
Quantile slice sampler for a random vector. The pseudo-target is specified
through independent univariate distributions.
}
\examples{
lf <- function(x) dbeta(x[1], 3, 4, log = TRUE) + dbeta(x[2], 5, 3, log = TRUE)
ps_shsc <- list(c(2, 2), c(2, 1))
ps_lpdf <- list(function(x) dbeta(x, ps_shsc[[1]][1], ps_shsc[[1]][2], log = T),
                function(x) dbeta(x, ps_shsc[[2]][1], ps_shsc[[2]][2], log = T))
ps_icdf <- list(function(x) qbeta(x, ps_shsc[[1]][1], ps_shsc[[1]][2]),
                function(x) qbeta(x, ps_shsc[[2]][1], ps_shsc[[2]][2]))
ps_cdf <- list(function(x) pbeta(x, ps_shsc[[1]][1], ps_shsc[[1]][2]),
               function(x) pbeta(x, ps_shsc[[2]][1], ps_shsc[[2]][2]))
draws <- matrix(0.2, nrow = 10e3, ncol = 2)
draws_u <- draws
draws_u[1,] <- sapply(1:length(ps_cdf), function(k) ps_cdf[[k]](draws[1,k]))
nEvaluations <- 0L
for (i in seq.int(2, nrow(draws))) {
  out <- slice_mv_transform(draws[i - 1, ], target = lf,
                    pseudo_log_pdf = ps_lpdf,
                    pseudo_inv_cdf = ps_icdf,
                    pseudo_cdf = ps_cdf)
  draws[i,] <- out$x
  draws_u[i,] <- out$u
  nEvaluations <- nEvaluations + out$nEvaluations
  cat(i, '\r')
}
nEvaluations / (nrow(draws) - 1)
nEvaluations / diag(ess(draws))
plot(draws[,1], draws[,2], xlim = c(0, 1))
hist(draws[,1], freq = F); curve(dbeta(x, 3, 4), col = "blue", add = TRUE)
hist(draws[,2], freq = F); curve(dbeta(x, 5, 3), col = "blue", add = TRUE)
plot(draws_u[,1], draws_u[,2], xlim = c(0, 1))
hist(draws_u[,1], freq = F)
hist(draws_u[,2], freq = F)
auc(u = draws_u[,1])
auc(u = draws_u[,2])
}
